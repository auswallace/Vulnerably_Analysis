import pandas as pd
import random
from datetime import datetime, timedelta

def generate_vulnerability_data(num_entries=5000, min_distinct_devices=100, min_distinct_vulns=50):
    # Define possible values for synthetic data
    os_types = ["Windows 10", "Windows Server 2019", "Linux Ubuntu", "Linux RHEL", "macOS Ventura"]
    exploit_available = ["Yes", "No"]
    patch_available = ["Yes", "No"]
    compliance_issue = ["Yes", "No"]

    # Ensure we generate enough distinct devices and vulnerabilities
    num_devices = max(min_distinct_devices, num_entries // 10)
    num_vulnerabilities = max(min_distinct_vulns, num_entries // 20)

    # Generate unique devices
    devices = [
        (f"DVC-{10000 + i}", f"host-{random.randint(100, 999)}", 
         f"192.168.{random.randint(0, 255)}.{random.randint(1, 254)}", random.choice(os_types))
        for i in range(num_devices)
    ]

    # Generate unique vulnerabilities
    vulnerabilities = [
        (f"CVE-{random.randint(2015, 2024)}-{random.randint(1000, 99999)}",  # CVE ID
         random.randint(10000, 99999),  # Plugin ID
         round(random.uniform(0, 10), 1),  # CVSS Score
         pd.Timestamp("2023-01-01") + pd.DateOffset(days=random.randint(0, 365))  # Random CVE publish date
        )
        for _ in range(num_vulnerabilities)
    ]

    # Function to calculate deterministic risk score based on CVSS
    def calculate_risk_score(cvss_score):
        if cvss_score < 4.0:
            return cvss_score * 50  # Low Risk
        elif cvss_score < 7.0:
            return cvss_score * 75  # Medium Risk
        elif cvss_score < 9.0:
            return cvss_score * 100  # High Risk
        else:
            return cvss_score * 125  # Critical Risk

    # Generate scan results
    scan_results = []
    today = pd.Timestamp.today()

    for _ in range(num_entries):
        device = random.choice(devices)
        vuln = random.choice(vulnerabilities)

        scan_date = pd.Timestamp("2024-01-01") + pd.DateOffset(days=random.randint(0, 365))
        
        # Ensure scan_date is not before cve_publish_date
        if scan_date < vuln[3]:
            scan_date = vuln[3] + pd.DateOffset(days=random.randint(1, 30))  # Push scan date forward

        # Compute vulnerability age
        vulnerability_age = (today - scan_date).days

        # Calculate deterministic risk score
        risk_score = round(calculate_risk_score(vuln[2]), 2)

        # Categorize device type based on OS
        device_type = "Server" if "Server" in device[3] or "Linux RHEL" in device[3] else "Workstation"

        scan_results.append([
            device[0], device[1], device[2], device[3], device_type,
            scan_date, vuln[0], vuln[3], vuln[1], vuln[2], risk_score,
            random.choice(exploit_available), random.choice(patch_available),
            random.choice(compliance_issue), vulnerability_age
        ])

    # Create DataFrame
    columns = [
        "device_id", "device_name", "ip_address", "os", "device_type",
        "scan_date", "vulnerability_id", "cve_publish_date", "plugin_id", "cvss_score",
        "risk_score", "exploit_available", "patch_available",
        "compliance_issue", "vulnerability_age"
    ]
    df = pd.DataFrame(scan_results, columns=columns)

    # Save to Documents folder
    output_path = "INSERT_PATH_HERE"
    df.to_csv(output_path, index=False)
    print(f"Dataset generated and saved as '{output_path}'")

    # Create a timestamped backup file
    filename = f"INSERT_PATH_HERE{pd.Timestamp.now().strftime('%Y%m%d_%H%M%S')}.csv"
    df.to_csv(filename, index=False)
    print(f"Backup saved as '{filename}'")

    return df

# Example usage
df = generate_vulnerability_data(num_entries=5000, min_distinct_devices=200, min_distinct_vulns=100)
